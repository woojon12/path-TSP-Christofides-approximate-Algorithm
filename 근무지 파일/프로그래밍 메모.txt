

자바에서

필드 (Field : 메서드와 생성자 밖에서 선언된 클래스 내 변수)
전역 변수 (애는 어쩌면 public 으로 선언되야 할지도)
멤버 변수 
는 모두 같은 말.

그리고 필드, 전변, 멤변의 부분집합으로

인스턴스 변수 (no static)
클래스 변수 (static)
가 있는 것.


-----------------------------------------------------------------

3차원 배열에서
3번째 인덱스만 이상한 곳을 가리키는 걸로는 오류가 나지 않는다.
심지어 정적할당(int arr[1][2][3])도 동적할당(int ***p = new int**[4] ...etc)도.
값을 대입해도 오류 안나고 값을 출력해도 오류 안난다. 대입한 거 잘 나온다

심지어 동적할당은 아무것도 대입 안하고 출력하면 그냥 0이 나온다.

그럼 문제가
어떠할 때 터지냐면
만약 1. 동적할당에게 2. 대입을 했다면
문제가 터지는데

그 후 바로 오류 터지는 게 아니고
어디서 터지냐면 뜬금
delete[] 할 때 터진다.

free(): invalid next size (fast)
signal: aborted (core dumped)
라는 오류가 뜬다.

나는 delete[] 에서 오류나길래 무슨 내가 잘못된 곳을 delete 했나 했는데
3일 내리 백만번 확인을 해도 절대 잘못된 구간을 delete[] 하지 않았다.
그런데도 런타임 에러가 뜨니까 전체 코드 눈빠지게 확인해보니
내가 잘못된 곳에 대입 좀 했다고 이러는 것.
그럼 대입 했을 때 오류 나줘

아래는 실험 증명 코드

#include <iostream>
using namespace std;

int main()
{
  int arr[3][4][5];
  int ***path_memory;
  int N = 4;

  path_memory = new int** [1 << N];
  for (int i = 0; i < (1 << N); ++i)
      path_memory[i] = new int* [N];
     for (int i = 0; i < (1 << N); ++i)
            for (int j = 0; j < N; ++j)
                path_memory[i][j] = new int[N - 1];

        for (int i = 0; i < (1 << N); ++i)
            for (int j = 0; j < N; ++j)
                for (int k = 0; k < N - 1; ++k)
                    path_memory[i][j][k] = -1;
  


  //arr[2][3][-1] = 1;
  path_memory[3][3][-1] = 1; //만약 이거 하나만 주석처리하면 아무런 오류가 안남

  //cout << arr[2][3][-1] << endl;
  cout << path_memory[3][3][-1] << endl;

  for (int i = 0; i < (1 << N); ++i) {
            for (int j = 0; j < N; ++j) {
                //cout << "(" << i << ", " << j << ")" << endl;
                delete[] path_memory[i][j];
            }
          delete[] path_memory[i];
        }         

  delete[] path_memory;

  cout << "program end" << endl;
}

결과는?

	1
	free(): invalid next size (fast)
	signal: aborted (core dumped)

라고 뜸.

실제로 자세히 말하면
어디에 잘못 대입했느냐에 따라
어디 delete[] 할 때 오류 나는지 바뀌는데
어쨋든 delete[] 뜬금 오류는 잘못된 곳 대입 때문이란 거.


-----------------------------------------------------------------------------------------

set은 그냥 iterator 를 써도 값의 변경이 불가능하다.
심지어 itr -> 이나 (*itr). 으로 멤버 변수 바꾸는 것(set에 클래스를 넣은 경우 시도됨)도 안 됨.
return *itr 과 같이 반환값으로 사용할 때도 반환형에 const가 명시되있어야 반환 가능하다. (const sometype& 처럼 레퍼런스일 때 기준.)

이런 큰 제약사항 때문에 set은 사실상
그 좋은 정렬기능을 위해 쓴다는 용법은 둘째이고
읽기 전용이 가능하냐 마느냐가 첫째임.

근데 사실 해결법이 있음.
c++에서 지원하는 여러가지 타입 캐스팅 중
const_cast 라는 게 있는데 이건 이름만 보면 const(상수)화 시킬 것 같지만
그게 아니라 반대로 const를 떼어버린다.

set<어떤 클래스> S; 라고 정의한 set의 반복자를 통해 수정하고 싶다?

const_cast<어떤 클래스&>(*itr) = 어떤대입
const_cast<어떤 클래스&>(*itr).어떤멤버변수 = 수정
이렇게 사용하면 가능하다.

물론 set에 정렬의 기능이 있는 이상 함부로 바꿨다가
추후 set이 비정상적으로 기능할 위험이 있으니 잘 다뤄야함.

참고로 for in 문으로

for (sometype st : someset) {
	st.somemember = 수정;
}

이렇게 하면 오류가 안 나서 잘 되는 줄 아는데
이건 그냥 st 라는 게 레퍼런스가 아니라 복사품이라서 되는거임.
즉 저거 다음에 

for (sometype st : someset) {
	cout << st.somemember << endl;
}
이라고 출력해보면 하나도 반영이 안 된걸 볼 수 있음

이 문법으로 수정하고 프면

for (sometype& st : someset)
이라고 &을 붙여야 하는데
set에서 이러면 무조건 에러 뜸.
결국 해결법은 똑같음.

for(const sometype& st : someset) 이라고 const 레퍼런스로 받아서 컴파일러를 방심시킨 뒤
const_cast<sometype&>(st) 로 쓰면 됨.



도움된 사이트
https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const
킹택 갓버플로우

-------------------------------------------------------------------------------------------

list 의 반복자(iterator)는
*(itr + 1) 이딴 거 안 된다.

그래서 차이가 있는 두 반복자가 필요하답시고

list<sometype>::iterator itr1 = somelist.begin()
list<sometype>::iterator itr2 = ++++itr1;
이렇게 하면 바보임. ++++itr1 에서 itr1도 같이 바뀌어서 itr1이랑 2가 그냥 같아짐.
다시 ----itr1 하든가. itr2 = itr1 이라고만 하고 ++++itr2; 하던가

그리고 splice는 복사가 아니라 떼어오기임.
자기자신에게서 떼어와서 이동시키기도 가능.

--------------------------------------------------------------------------------------------

벡터는 at 이란 기능도 있고 반복자랑 정수를 더하는 연산도 지원하는 만큼

반복자 간의 뺄셈도 지원한다.
이를 이용해 반복자가 몇번째 인덱스를 가리키는 셈인지도 구할 수 있음

3번째 가리키는 반복자 - somevector.begin()
이렇게 해주면 size_t 타입의 3을 반환함.

--------------------------------------------------------------------------------------------

list 는 end()이터레이터에 원소 개수를 넣는 것으로 확인됨
list<int>로 실험된거긴 한데 어쨋든 *somelist.end() 를 cout 해보니 리스트에 남은 원소의 개수가 즉시 반영됨이 관측됨

splice를 한 이후 splice 붙여넣기 한 곳 다음의 반복자를 얻고 싶으면
splice(인자4개 기준)에 맨 마지막 인자로 넣은 반복자의 바로 이전 반복자를 잠시 저장해뒀다가
splice 이후 저장해둔 반복자를 ++ 해주면 원하는 반복자 얻음.

--------------------------------------------------------------------------------------------

복사가 아닌 참조로 시간을 단축하려고

const sometype& 을 남발했다간

설령 const 여도 다른 레퍼런스 변수가 바꿔버리는 걸 막을 수 없음

대표적인 레퍼런스인 반복자가 특히 그 변수를 건드려서
const인데도 바뀌는 경우가 있을 수 있는데 그럼 그냥 &을 떼야함

---------------------------------------------------------------------------------------------

somevector.erase( itr ) 하면
itr은 자동으로 지워진 것 다음을 가리키는 반복자가 된다
때문에 ++itr을 반드시 하는 for문 속에서 erase를 한다면
자동으로 한 칸 앞으로 가기 때문에
somevector.erase( itr-- ) 로 후위연산자를 알차게 써줘야 한다.

---------------------------------------------------------------------------------------------

static 변수는 초기화식이 단 한 번만 실행되고
이후 다시 그 함수 따위가 호출되어 다시 마주해도
초기화 표현은 실행되지 않는다

static int a = 2; 하면 = 2는 단 한번만 실행됨
그러나

static int a;
a = 2;

라고 대입의 표현을 했다면 계속 실행됨

딱히 특별한 건 아니지만
변수를 대입할 때도 똑같음

static int a = somevariable
이라고 하면 somevariable이 나중에 변해도
가장 처음에만 한 번만 대입되고 반영안됨

-------------------------------------------------------------------------------------------

set의 <> 꺾쇠 안에다 기본자료형(int 등)이 아닌
자신의 클래스를 넣는다면
반드시 그 클래스의 인스턴스를 비교하는 operator< 가 있어야 한다.
심지어 friend를 써서 외부함수로서 있어야 한다

그리고 매개변수도 반드시 '변경가능성이 있는' 식으로 받아서는 안된다

someclass 라는 클래스를 만들었는데
인자가

friend bool operator<(someclass& sc1, someclass& sc2);

이런 식으로 레퍼런스면 안된다는 것.
레퍼런스로 할 거면 const도 같이 넣던가
아님 그냥 레퍼런스 빼서 복사품으로 받으면 const 없어도 됨.

이 때문에 멤버함수로서 있지말고 friend로 있어야 하는 것.
멤버함수로 작성하면 '<' 비교 연산에서 왼쪽에 있는 놈이 무조건 변경 가능성이 있기 때문.

-----------------------------------------------------------------------------------------

2 - 3 - 6 - 10 - 14 - 17 - 21 - 25 - 24 - 23 - 19 - 20 - 16 - 12 - 8 - 7 - 4 - 0 - 1 - 5 - 9 - 13 - 11 - 15 - 18 - 22

22 - 18 - 15 - 11 - 7 - 13 - 9 - 5 - 2 - 1 - 0 - 4 - 8 - 12 - 16 - 19 - 20 - 23 - 24 - 25 - 21 - 17 - 14 - 10 - 6 - 3